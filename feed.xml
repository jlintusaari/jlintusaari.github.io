<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <generator uri="http://jekyllrb.com" version="3.8.3">Jekyll</generator>
  
  
  <link href="/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2018-07-16T18:43:09-05:00</updated>
  <id>//</id>

  
    <title type="html">Jarno’s blog</title>
  

  
    <subtitle>This blog features coding and machine learning related free-time projects.</subtitle>
  

  
    <author>
        <name>Jarno Lintusaari</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Building a Boggle solver from scratch using Keras</title>
      
      
      <link href="/2018/06/building-boggle-solver/" rel="alternate" type="text/html" title="Building a Boggle solver from scratch using Keras" />
      
      <published>2018-06-27T00:00:00-05:00</published>
      <updated>2018-06-27T00:00:00-05:00</updated>
      <id>/2018/06/building-boggle-solver</id>
      <content type="html" xml:base="/2018/06/building-boggle-solver/">&lt;p&gt;Boggle is a classical word searching game in a 4 x 4 grid of letter dice.
The winner is determined based on the number and length of words found from the board.
We quite often play this game when visiting my parents. 
The inspiration for this project came from an interest in knowing all the possible words in
a given board.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/boggle.jpg&quot; alt=&quot;A finnish boggle board&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So I decided to write a program that automates the process of finding the words from the game board.
To make the program easy to use, the input is just an image of a boggle board. The program returns 
all the words in the board that are found from a dictionary file.&lt;/p&gt;

&lt;h2 id=&quot;subproblems-to-solve&quot;&gt;Subproblems to solve&lt;/h2&gt;

&lt;p&gt;There are two main tasks:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Read the boggle board letters from an image&lt;/li&gt;
  &lt;li&gt;Find all the words&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the latter task, there exists pre-made solutions in GitHub (see e.g. &lt;a href=&quot;https://github.com/railto/boggle-solver&quot;&gt;here&lt;/a&gt;). 
This article considers the first task.&lt;/p&gt;

&lt;p&gt;The biggest problem was to acquire a decent dataset. 
I had beforehand decided to use artificial neural networks (ANN), and those tend to require a lot of 
labeled training data. 
I first thought of rendering boggle board images with a computer but came into a conclusion that 
making the renderer would take too much time. 
I decided to take a few photos of the board and use them to generate more images for training.&lt;/p&gt;

&lt;p&gt;Next time when I visited my parents, I took eight images of our game board with all the 
different die faces visible.&lt;/p&gt;

&lt;h2 id=&quot;locating-the-board&quot;&gt;Locating the board&lt;/h2&gt;

&lt;p&gt;Given the shortage of training data, I decided to use traditional image processing techniques to 
first locate the board in the image. 
Once located, it would be easy to extract the individual letter images from it.
Then I would only need to train an ANN classifier to classify the letters in each die.&lt;/p&gt;

&lt;p&gt;I had not done much image processing before but found a blog entry describing &lt;a href=&quot;http://sudokugrab.blogspot.fi/2009/07/how-does-it-all-work.html&quot;&gt;Sudoku grab&lt;/a&gt;
quite useful. 
After some experimentation I arrived at the following approach for locating the Boggle board in an 
image:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Assume an image with a boggle board (possibly with some other objects, e.g. a hand).&lt;/li&gt;
  &lt;li&gt;Assume dice have a white background. Threshold the image to find all whitish blobs in it.&lt;/li&gt;
  &lt;li&gt;Do outlier detection to determine what blobs are actually dice among.
all the white blobs. Remove the others.&lt;/li&gt;
  &lt;li&gt;Dilate the blobs until there is just one blob.&lt;/li&gt;
  &lt;li&gt;This blob should now be basically the board. Find the minimal enclosing rectangle.&lt;/li&gt;
  &lt;li&gt;Do a pespective transform to get the image of the board in upright position.&lt;/li&gt;
  &lt;li&gt;Extract each die from the upright board image&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is an example of the results after each of the above steps:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/board-capturing_9_0.png&quot; alt=&quot;Image processing steps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The outlier detection in step three worked surprisingly well. 
I added it after I noticed that the thresholding alone was too unreliable.
The image had to basically contain just the Boggle board and not much else. 
With the outlier detection, however, even having a hand, a sheet of paper, or even 
light reflection from the table didn’t confuse the program. 
I used three features for the outlier detection, the size of the blob, the blob location and the 
minimum bounding rectangle width in proportion to its height.&lt;/p&gt;

&lt;p&gt;After extraction of the features the program locates 24 largest white blobs in the image, 
and assumes that 16 of them are dice (as there are 16 dice). 
The remaining eight blobs are “outliers” to be removed, e.g. a white sheet of paper next to the game board.
Because the blobs corresponding to the 16 dice should have very similar blob feature values, the 
outlier detection algorithm should be able to label the other white blobs as outliers. 
The outlier detection algorithm I used was the &lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/sklearn.covariance.EllipticEnvelope.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EllipticEnvelope&lt;/code&gt;&lt;/a&gt; 
from &lt;a href=&quot;http://scikit-learn.org/stable/index.html&quot;&gt;scikit-learn&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is another illustration of the process for another image:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/board-capturing_7_0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This process is not perfect in that it requires that the image is taken quite directly from above the 
board. 
It also makes errors occasionally in bad lighting conditions because of the thresholding.
However, this solution was sufficient for me for now and turned out to work pretty well in practice.
The implementation used &lt;code class=&quot;highlighter-rouge&quot;&gt;scipy.ndimage&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;open-cv&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;numpy&lt;/code&gt; Python libraries.&lt;/p&gt;

&lt;h2 id=&quot;generating-a-training-dataset&quot;&gt;Generating a training dataset&lt;/h2&gt;

&lt;p&gt;I decided to use artificial neural networks (ANN) to classify the letter in the image of a die.
I first tried to find ready made letter datasets, but gave up after realizing that they were all for 
the english alphabet. That meant that I would anyway have to add the Ö, Ä letters to the dataset as 
well as the combined FG and BC letter dice from the finnish Boggle version.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/accented.jpg&quot; alt=&quot;Finnish boggle dice&quot; style=&quot;width: 200px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I decided to use six out of the eight of the previously taken images of the board to generate 
more training images by using random distortions. 
The six game board images each had 16 dice in them that gave me an initial seed set of 6 * 16 = 96 
images of a die (all the different sides of the dice in the game).
First I labeled the die images by hand.
To start increasing the size of my dataset, I then took a blurred and sharpened version of the 6 
original images to bring my dataset size to 96 * 3 = 288 labeled images of Boggle letters.&lt;/p&gt;

&lt;p&gt;I decided to cast the dice images to black and white 64 x 64 pixel images for classification.
After this I made a function that would add random noise (salt and pepper), shifts, and rotations to 
the images. 
Below you can see some of the original 288 black and white letter images and the result of the 
above random noising on the right.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/creating-dataset_8_0.png&quot; alt=&quot;Preprocessed letter images&quot; style=&quot;width: 300px;&quot; /&gt;
&lt;img src=&quot;/img/boggle/creating-dataset_11_0.png&quot; alt=&quot;Preprocessed and noised letter images&quot; style=&quot;width: 300px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I would use these randomly noised images to train my classifier.
Because the distribution of the letters was not uniform (e.g. there were many more A:s compared to 
e.g. Y:s) I sampled them with weights to have an even probability of each letter appearing in a
random sample.&lt;/p&gt;

&lt;p&gt;I was now ready to train the ANN with a sort of an unlimited supply of training letter images and
hoped that the above steps would be enough for the classifier to generalize to unseen images 
given the tiny seed set of training images.&lt;/p&gt;

&lt;h2 id=&quot;training-the-ann&quot;&gt;Training the ANN&lt;/h2&gt;

&lt;p&gt;I used &lt;a href=&quot;https://keras.io/&quot;&gt;Keras&lt;/a&gt; with the &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;TensorFlow&lt;/a&gt; backend to 
implement the ANN model. 
I decided to start with the basic one hidden layer setup with relu activation and a softmax loss. 
Because the training data are rather heavily preprocessed black and white images of letters, I 
anticipated that this ANN structure would already yield a decent performance.&lt;/p&gt;

&lt;p&gt;Below is the Keras code of the ANN model with a hidden layer size of 192.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keras&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_shape&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Activation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'softmax'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keras&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimizers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SGD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'categorical_crossentropy'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'sgd'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;metrics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'accuracy'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I used random batches of 1000 noised letters in training the classifier.
Using the original 288 letters training set (without random noising) as a validation set I 
reached over 80%  accuracy after just some tens of thousands of iterations. 
After a few hundred thousands more I reached 100% accuracy, i.e. my model at least had nicely 
(over)fitted to the original training dataset.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/training-classifier_17_0.png&quot; alt=&quot;28 original images&quot; style=&quot;width: 300px; float: right;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I then took a look at the ANN hidden layer weights which seemed to had formed rather reasonable 
looking shapes for detecting letters in different 90 degree rotations. 
The image on the right shows the first 20 out of the 192 hidden layer node weight maps arranged such that there are four maps on each row.&lt;/p&gt;

&lt;p&gt;I then tried the classifier on a batch of 1000 randomly noised images.
With that the accuracy was roughly 98%, i.e. around 20 misclassified letters per batch.
For the boggle solver to work, it needs to be able to correctly recognize all the letters in the 
board at once, so I thought this would need to be higher.&lt;/p&gt;

&lt;p&gt;I decided to let it train 32M letters overnight (using CPU only here) and see if the accuracy would 
improve. 
On the next morning the performance was mostly 100% percent for batches of 1000 randomly noised
letter images although on rare occasion a single letter would be misclassified.
Since the perfomance could not really be meaningfully improved, I decided not to develop the model 
further with e.g. convolutional layers.&lt;/p&gt;

&lt;h3 id=&quot;examples-of-missclassifications&quot;&gt;Examples of missclassifications&lt;/h3&gt;

&lt;p&gt;Below are a couple of examples of misclassified randomly noised images. 
The first one was classified as “S” while it should have been an “M” and the second one was 
classified as “A” but should have been an “Ä”. 
You can’t blame the ANN from the second one though: the random shift pushed the dots outside of the 
image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/boggle/training-classifier_21_1.png&quot; alt=&quot;A missclassified letter&quot; /&gt;
&lt;img src=&quot;/img/boggle/training-classifier_23_1.png&quot; alt=&quot;A missclassifier letter&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;testing-the-solver&quot;&gt;Testing the solver&lt;/h2&gt;

&lt;p&gt;I had left out two images from the training set to serve as a test set. 
So I had a total of 2 * 16 = 32 images of letters for the test set – not too many but that would have to do.&lt;/p&gt;

&lt;p&gt;Evaluating the model with the 32 unseen letter images gave a 100% accuracy with a loss of 5.6e-6.
This was encouraging, but due to the minuscule size of the test set, it would really need to be 
tested in practice.&lt;/p&gt;

&lt;p&gt;When testing the first time in practice, it turned out that the lighting condition in the original 8 images
was too alike that the program was not able to locate the board nor do the black and white transform properly 
with new images having a different lighting condition.
In other words there was a considerable bias in the original sample with respect to the lighting. 
I had to tune the thresholding in the image processing part a bit to make it more robust.
The ANN classifier however did not undergo any changes and performed surprisingly well with the 
black and white images right from the beginning.
With the ANN, the problem setup was simple enough and the letter noising sufficient for allowing the classifier to 
generalize to unseen letter images.&lt;/p&gt;

&lt;p&gt;The resulting classifier can be tried online &lt;a href=&quot;http://kevea.fi:8000&quot;&gt;here&lt;/a&gt;. 
The web interface would benefit from a bit more work as it is quickly put together for my family’s Boggle games.
Notice that in order to work, the images must conform to the assumptions made above, such as that the
dice must have a white background.
It has not been tested with other boggle boards besides the one that my parents own (see the image in the beginning of this post). 
It won’t recognize letters that are not present in the dice set of the finnish Boggle version, such
as B or C. Also for now, the words found will be in finnish ;)
However, we have successfully used it and enjoyed it in our Boggle games!&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Jarno Lintusaari</name>
          
          
        </author>
      

      
        <category term="Machine Learning" />
      
        <category term="Keras" />
      
        <category term="Image Processing" />
      

      

      
        <summary type="html">Boggle is a classical word searching game in a 4 x 4 grid of letter dice. The winner is determined based on the number and length of words found from the board. We quite often play this game when visiting my parents. The inspiration for this project came from an interest in knowing all the possible words in a given board.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Making a GitHub hosted Jekyll blog with a custom theme</title>
      
      
      <link href="/2018/06/github-hosted-jekyll-blog-custom-theme/" rel="alternate" type="text/html" title="Making a GitHub hosted Jekyll blog with a custom theme" />
      
      <published>2018-06-13T00:00:00-05:00</published>
      <updated>2018-06-13T00:00:00-05:00</updated>
      <id>/2018/06/github-hosted-jekyll-blog-custom-theme</id>
      <content type="html" xml:base="/2018/06/github-hosted-jekyll-blog-custom-theme/">&lt;p&gt;I have been thinking of making a blog for a while.
I wanted to find a blogging platform that was simple, customizable, static content based so that I 
could host it in &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub pages&lt;/a&gt;, and supported Markdown so that I could easily publish 
code projects from Jupyter notebooks and R’s &lt;a href=&quot;https://yihui.name/knitr/&quot;&gt;knitr&lt;/a&gt;.
After a bit of searching I decided to go forward with &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; which is a Ruby based blogging 
platform that seems to have the above features.&lt;/p&gt;

&lt;h3 id=&quot;why-github-pages&quot;&gt;Why GitHub pages&lt;/h3&gt;

&lt;p&gt;GitHub provides hosting for static content sites via it’s &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub pages&lt;/a&gt;.
This is really convenient as one does not have to bother setting up a production server and the 
pages are automatically served from a git repository.
All you need to do is to push your content into a special repository (more of this below).&lt;/p&gt;

&lt;p&gt;What is neat with &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub pages&lt;/a&gt; for &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; is that Jekyll based pages can 
automatically built by GitHub, meaning that the static content is automatically compiled from 
the Jekyll source files, such as those Markdown files. 
Given that GitHub was originally &lt;a href=&quot;http://shayfrendt.com/posts/upgrading-github-to-rails-3-with-zero-downtime/&quot;&gt;built with Ruby On Rails&lt;/a&gt;, the famous Ruby based 
web-application framework, it’s no wonder that GitHub gave the Ruby based &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; a special support.
However, I ended up not using that neatness due to a missing gem (Ruby library) in the GitHub 
environment that was required by my custom theme.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-a-developer-environment&quot;&gt;Setting up a developer environment&lt;/h2&gt;

&lt;p&gt;It’s essential to be able to test your site in your local computer.
Jekyll is based on Ruby which needs to be installed if you want to compile your blog from the source
files. 
Installing Ruby and learning it’s ecosystem will take some time, so unless you have that ready it is
probably the easiest to use &lt;a href=&quot;https://docs.docker.com/install/&quot;&gt;Docker&lt;/a&gt; instead.&lt;/p&gt;

&lt;p&gt;Jekyll has an official &lt;a href=&quot;https://hub.docker.com/r/jekyll/jekyll/&quot;&gt;docker image&lt;/a&gt; that has all the needed components installed.
The following instructions will be based on Docker and assumes you have a working Docker installed
to your computer and you are using linux. If you are using Windows 10, you can either use the bash 
shell within Windows or just modify the commands below.&lt;/p&gt;

&lt;p&gt;The philosophy behind the Docker commands below is that if we had Ruby environment installed locally, 
we could just run commands like &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;bundle install&lt;/code&gt; to build a new blog or install 
Ruby libraries (called &lt;em&gt;gems&lt;/em&gt;). 
Now instead we will run such commands with &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; through the container that has the 
Ruby environment installed.&lt;/p&gt;

&lt;h3 id=&quot;creating-the-initial-jekyll-source-files-with-docker&quot;&gt;Creating the initial jekyll source files with Docker&lt;/h3&gt;

&lt;p&gt;We will use the official &lt;a href=&quot;https://hub.docker.com/r/jekyll/jekyll/&quot;&gt;Jekyll Docker image&lt;/a&gt; to build the initial source files for
the blog. 
You can find the files created in this section from &lt;a href=&quot;https://github.com/jlintusaari/local-jekyll-docker&quot;&gt;this repository&lt;/a&gt; that I created.
To start, first create a folder for the blog, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir blog&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The initial Jekyll blog files can now be created into the &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; folder with 
&lt;a href=&quot;https://hub.docker.com/r/jekyll/jekyll/&quot;&gt;Jekyll Docker image&lt;/a&gt; (I used &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll/jekyll:3.8&lt;/code&gt;) by running:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm --volume=&quot;$PWD/blog:/srv/jekyll&quot; -it jekyll/jekyll:3.8 \
  jekyll new . --skip-bundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The command mounted your &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; directory to &lt;code class=&quot;highlighter-rouge&quot;&gt;/srv/jekyll&lt;/code&gt; in the container and then created the 
blog files with &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new&lt;/code&gt;. 
The source files should now appear in your &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; folder.
Additional info about the command used above can be found from &lt;a href=&quot;https://github.com/jlintusaari/local-jekyll-docker&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It may be beneficial to open an interactive shell to the container to test the different commands, 
for instance to open an interactive bash shell type:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm --volume=&quot;$PWD/blog:/srv/jekyll&quot; -it jekyll/jekyll:3.8 \
  bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now you can check the options for &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new --help&lt;/code&gt; (note that in the first time
it will install bunch of gems).&lt;/p&gt;

&lt;p&gt;Some files that we will be needing are &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt; which lists the gems (Ruby libraries) that your project will
use and &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; which is the Jekyll site configuration file.&lt;/p&gt;

&lt;h3 id=&quot;running-the-server-locally-with-docker&quot;&gt;Running the server locally with Docker&lt;/h3&gt;

&lt;p&gt;The fastest way to run the server is to change directory to the &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; folder 
(that contains the source files) and type:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm --volume=&quot;$PWD:/srv/jekyll&quot; -p 4000:4000 -it jekyll/jekyll:3.8 \
  bash -c &quot;bundle install &amp;amp;&amp;amp; bundle exec jekyll serve -H 0.0.0.0&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You should see information about the server staring. If not, make sure you are in the same folder
where you have the source files created above (the &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; folder in this example).
Now you should have your blog running in &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:4000&lt;/code&gt; so go ahead and type that to your
browser’s address bar to test. 
Details of the arguments to &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; can be found from &lt;a href=&quot;https://github.com/jlintusaari/local-jekyll-docker&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;While the server is running you can edit the different files to see their effect. 
For instance you can modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;about.md&lt;/code&gt; file and see how the About page is changed after you
save the changes.
Exceptions are the files &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt; that require restarting the server.&lt;/p&gt;

&lt;h3 id=&quot;speeding-up-the-starting-of-the-server&quot;&gt;Speeding up the starting of the server&lt;/h3&gt;

&lt;p&gt;The above process always reinstalls the needed gems to the container based on the official image. 
A more efficient way is to first create an image that has the needed gems and then use that image.
This will actually speed up all the other commands too. 
Assuming we are in the &lt;code class=&quot;highlighter-rouge&quot;&gt;blog&lt;/code&gt; folder, type:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name blog_server --volume=&quot;$PWD:/srv/jekyll&quot; -it jekyll/jekyll:3.8 \
  bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that we removed the &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt; argument which would remove the container after execution. Instead 
we added &lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt; to give the container a name &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_server&lt;/code&gt;. Now typing &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; 
should show you a container with that name. It has all the gems installed
and the final step is to make an image of it with &lt;code class=&quot;highlighter-rouge&quot;&gt;docker commit&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker commit blog_server blog_server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we have an image called &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_server&lt;/code&gt; that is based on the official image and has all the needed 
gems installed. 
You can see this image listed by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;docker images&lt;/code&gt;. 
The server can now be ran using our new image with&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm --volume=&quot;$PWD:/srv/jekyll&quot; -p 4000:4000 -it blog_server \
  bundle exec jekyll serve -H 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You will notice that server starts in an instant. 
As long as you keep the image in your computer you can use it to serve the blog. 
If you at some point update your bundle (Gemfile) you can recreate the image with the steps above.&lt;/p&gt;

&lt;h2 id=&quot;customizing-the-blog&quot;&gt;Customizing the blog&lt;/h2&gt;

&lt;p&gt;The first thing in customizing the blog is to choose a theme.
If you are planning to host in GitHub with automatic compilation, you can choose the theme from 
multiple &lt;a href=&quot;https://pages.github.com/themes/&quot;&gt;options&lt;/a&gt; or even use custom themes via the 
&lt;a href=&quot;https://github.com/benbalter/jekyll-remote-theme&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll-remote-theme&lt;/code&gt;&lt;/a&gt; gem.
To test locally you need to replicate the GitHub Ruby environment.
Luckily GitHub makes this really easy, you just need to have&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem &quot;github-pages&quot;, group: :jekyll_plugins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;in your &lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt; and remove the &lt;code class=&quot;highlighter-rouge&quot;&gt;gem &quot;jekyll&quot;&lt;/code&gt; line. 
This will install all the gems in your local environment that are provided at GitHub.&lt;/p&gt;

&lt;p&gt;I had already chosen a &lt;a href=&quot;https://github.com/yous/whiteglass&quot;&gt;theme&lt;/a&gt; that was not in the list of GitHub supported themes and 
unfortunately depended on a gem called &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll-archives&lt;/code&gt; that was not available in the GitHub Ruby 
environment.
This caused the post tags to silently disappear from the posts in compilation (luckily I noticed it).
I figured the safest and easiest way forward at this stage would be to just build the pages locally, 
and push the compiled static pages to GitHub.
That way I wouldn’t have to worry about what’s available in the GitHub Ruby environment and what’s 
not.
Of course this means more manual work for me, but not that much.&lt;/p&gt;

&lt;p&gt;I followed the &lt;a href=&quot;https://github.com/yous/whiteglass#quick-start&quot;&gt;quick start instructions&lt;/a&gt; of the theme to edit
my source files.&lt;/p&gt;

&lt;h2 id=&quot;hosting-in-github&quot;&gt;Hosting in GitHub&lt;/h2&gt;

&lt;p&gt;The last step is to have GitHub host the compiled pages. GitHub has made this really 
&lt;a href=&quot;https://pages.github.com/&quot;&gt;simple&lt;/a&gt;. 
You only need to create a git repository with a special name &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; and all the 
static content you push to it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; branch will be available at 
&lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;username&amp;gt;.github.com&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A small nuisance in my case is that I need to manually compile the pages and then push the compiled 
pages to GitHub. 
To compile the pages with Docker one can either:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --volume=&quot;$PWD:/srv/jekyll&quot; -it jekyll/jekyll:3.8 \
  jekyll build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or use the &lt;code class=&quot;highlighter-rouge&quot;&gt;blog_server&lt;/code&gt; image created above&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --volume=&quot;$PWD:/srv/jekyll&quot; -it blog_server \
  jekyll build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The compiled pages are now found from the &lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt; folder. 
The contents of this folder need to be committed to the master branch of the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; 
repository and pushed.&lt;/p&gt;

&lt;p&gt;To automate this I slightly modified the build command to place the files directly to the 
local clone of the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt; repository:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -v=&quot;$PWD:/srv/jekyll&quot; -v=&quot;path/to/github_repo:/srv/site&quot; -it blog_server \
  jekyll build -d /srv/site
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now the compiled static files are automatically placed to the local &lt;code class=&quot;highlighter-rouge&quot;&gt;path/to/github_repo&lt;/code&gt; 
folder. After committing and pushing you should see your blog appearing at 
&lt;code class=&quot;highlighter-rouge&quot;&gt;https://&amp;lt;username&amp;gt;.github.com&lt;/code&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Jarno Lintusaari</name>
          
          
        </author>
      

      
        <category term="Jekyll" />
      
        <category term="GitHub" />
      
        <category term="Docker" />
      
        <category term="Blog" />
      

      

      
        <summary type="html">I have been thinking of making a blog for a while. I wanted to find a blogging platform that was simple, customizable, static content based so that I could host it in GitHub pages, and supported Markdown so that I could easily publish code projects from Jupyter notebooks and R’s knitr. After a bit of searching I decided to go forward with Jekyll which is a Ruby based blogging platform that seems to have the above features.</summary>
      

      
      
    </entry>
  
  
</feed>
